// Copyright 2021 Bryan Cua. ALl rights reserved.

// Package opentest implements parsing of YAML files that define tests for openapi3 specifications. These tests can be
// used as a contract between SDKs and the underlying REST server.
package opentest

import (
	"errors"
	"os"

	"github.com/getkin/kin-openapi/openapi3"
	"gopkg.in/yaml.v3"
)

var (
	ErrInvalidDefinitionNotMap = errors.New("definition must be a map")
)

// Definition of a test YAML file. THe test yaml file should be verified against an OPENAPI3 document.
type Definition struct {
	// Info block
	Info Info `yaml:"info"`

	// Examples represent shared entities used by other parts of the test. They can be referenced through
	// a ref attribute starting with "./objects/".
	Examples map[string]*Example `yaml:"examples"`

	// Tests make up the rest of the YAML file.
	Tests map[string]*Test `yaml:"tests"`
}

// UnmarshalYAML satisfies the yaml.Unmarshaller interface to extract yaml nodes into the definition file.
func (d *Definition) UnmarshalYAML(node *yaml.Node) error {
	if node.Kind != yaml.MappingNode {
		return ErrInvalidDefinitionNotMap
	}

	// Change from []*Node to a map string interface
	t := make(map[string]*Test)
	for i := 0; i < len(node.Content); i += 2 {
		v := node.Content[i+1]

		var test Test
		switch node.Content[i].Value {
		case "info":
			if err := v.Decode(&d.Info); err != nil {
				return err
			}
		case "examples":
			if err := v.Decode(&d.Examples); err != nil {
				return err
			}
		default:
			if err := v.Decode(&test); err != nil {
				return err
			}
			t[node.Content[i].Value] = &test
		}
	}
	d.Tests = t

	// Go through all the test & values to make sure that they don't contain "./examples/". If they do, they
	// need to be replaced.
	for _, t := range d.Tests {
		if err := t.Resolve(d); err != nil {
			return err
		}
	}

	return nil
}

// Validate against the openapi3 specification.
func (d *Definition) Validate(spec *openapi3.T) error {
	for _, e := range d.Examples {
		if err := e.Validate(spec); err != nil {
			return err
		}
	}
	for _, t := range d.Tests {
		if err := t.Validate(d, spec); err != nil {
			return err
		}
	}
	return nil
}

// GetExample returns an example
func (d *Definition) GetExample(ref string) (*Example, error) {
	if !IsValidExampleRef(ref) {
		return nil, ErrExampleRefInvalid
	}
	parts := GetExampleRefParts(ref)
	ex, ok := d.Examples[parts[0]]
	if !ok {
		return nil, ErrExampleNotFound
	}
	return ex, nil
}

func (d *Definition) GetExampleOrPart(ref string) (interface{}, error) {
	if !IsValidExampleRef(ref) {
		return nil, ErrExampleRefInvalid
	}
	parts := GetExampleRefParts(ref)
	ex, ok := d.Examples[parts[0]]
	if !ok {
		return nil, ErrExampleNotFound
	}
	if len(parts) == 1 {
		return ex.Value, nil
	}

	return ex.GetPart(parts[1:])
}

// ParseFile parses a yaml definition file.
func ParseFile(file string) (*Definition, error) {
	b, err := os.ReadFile(file)
	if err != nil {
		return nil, err
	}

	var d Definition
	if err := yaml.Unmarshal(b, &d); err != nil {
		return nil, err
	}

	return &d, nil
}
