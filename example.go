package opentest

import (
	"errors"
	"log"
	"strconv"
	"strings"

	"github.com/cyc-ttn/openapi/openapi3"
)

var (
	ErrExampleInvalidSchema       = errors.New("example invalid schema")
	ErrExampleNotFound            = errors.New("example not found")
	ErrExampleRefInvalid          = errors.New("ref invalid for example")
	ErrExampleRefPartInvalid      = errors.New("example ref part invalid")
	ErrExampleSchemaDoesNotMatch  = errors.New("example schema does not match value")
	ErrExampleSchemaEmpty         = errors.New("example has empty schema")
	ErrExampleSchemaNotFound      = errors.New("example schema not found")
	ErrExampleSchemaUnresolvedRef = errors.New("example unresolved ref")
)

// Example defines a shared example object. For example, a test can go through these objects and add it to their test
// database to run tests.
type Example struct {

	// Schema that the Example adheres to. This should be a reference to the original OPENAPI3 specification (denoted by
	// #/components/schemas).
	Schema string

	// Value is freeform and denotes the data of the example. This data should be parsed to make sure it adheres to the
	// schema.
	Value interface{}
}

func ValidateOnSchema(v interface{}, schema *openapi3.SchemaRef) error {
	if schema.Value == nil {
		if schema.Ref == "" {
			return ErrExampleSchemaEmpty
		}
		return ErrExampleSchemaUnresolvedRef
	}
	if err := schema.Value.VisitJSON(v); err != nil {
		log.Print(err)
		return ErrExampleSchemaDoesNotMatch
	}
	return nil
}

func (e *Example) Validate(spec *openapi3.T) error {
	if e.Schema[:21] != "#/components/schemas/" {
		return ErrExampleInvalidSchema
	}
	value := e.Schema[21:]
	schema, ok := spec.Components.Schemas[value]
	if !ok {
		return ErrExampleSchemaNotFound
	}
	return ValidateOnSchema(e.Value, schema)
}

// GetPart returns a part of an example, if it exists. The ref should not contain the beginning elements.
func (e *Example) GetPart(parts []string) (interface{}, error) {
	if len(parts) == 0 {
		return nil, ErrExampleRefPartInvalid
	}
	curr := e.Value
	for len(parts) > 0 {
		switch v := curr.(type) {
		case map[string]interface{}:
			curr = v[parts[0]]
		case []interface{}:
			idx, err := strconv.Atoi(parts[0])
			if err != nil {
				return nil, err
			}
			curr = v[idx]
		}
		parts = parts[1:]
	}
	return curr, nil
}

func IsValidExampleRef(t string) bool {
	if len(t) < 12 {
		return false
	}
	return t[0:11] == "./examples/"
}

func GetExampleRefParts(t string) []string {
	return strings.Split(t[11:], "/")
}
