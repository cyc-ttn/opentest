package opentest

import (
	"errors"
	"net/http"

	"github.com/cyc-ttn/openapi/openapi3"
)

var (
	ErrTestPathDoesNotExist          = errors.New("test path does not exist")
	ErrTestSetupDoesNotExist         = errors.New("test has setup that does not exist")
	ErrTestSecurityThemeDoesNotExist = errors.New("test security theme does not exist")
)

// Test defines a test to be run for the server. An SDK can use this to generate a server stub. A server can use this
// to validate their routes.
type Test struct {
	// Route for the test (if provided)
	Route string

	// Method for the test (if provided)
	Method string

	// Description of the test
	Description string

	// Setup is a list of strings indicating the examples that need to be setup for this test.
	// Each should reference directly the string key that is used to extract an example from the definition.
	Setup        []string
	SetupObjects []*Example

	// UrlParams define the parameters in the URL for the test
	UrlParams map[string]*Value `yaml:"urlParams"`

	// Query are query string parameters
	Query map[string]*Value `yaml:"query"`

	// Security maps out a
	Security []*Security

	// RequestBody for the test
	RequestBody *RequestBody `yaml:"requestBody"`

	// Response to check for the test
	Response *Response

	// After defines tests that happen after the current test. "setup" inside these tests will be ignored.
	After []*Test `yaml:"after"`
}

// Resolve all internal references.
func (t *Test) Resolve(d *Definition) error {
	t.SetupObjects = make([]*Example, 0, len(t.Setup))
	for _, s := range t.Setup {
		obj, ok := d.Examples[s]
		if !ok {
			return ErrTestSetupDoesNotExist
		}
		t.SetupObjects = append(t.SetupObjects, obj)
	}
	for _, s := range t.Security {
		if err := s.Resolve(d); err != nil {
			return err
		}
	}
	for _, v := range t.UrlParams {
		if err := v.Resolve(d); err != nil {
			return err
		}
	}
	for _, v := range t.Query {
		if err := v.Resolve(d); err != nil {
			return err
		}
	}
	if t.RequestBody != nil {
		if err := t.RequestBody.Resolve(d); err != nil {
			return err
		}
	}
	if t.Response != nil {
		if err := t.Response.Resolve(d); err != nil {
			return err
		}
	}
	return nil
}

func (t *Test) Validate(d *Definition, spec *openapi3.T) error {
	// Setup must match the values in examples
	for _, s := range t.Setup {
		if _, ok := d.Examples[s]; !ok {
			return ErrTestSetupDoesNotExist
		}
	}

	// Security keys must exist in spec security.
	for _, s := range t.Security {
		if _, ok := spec.Components.SecuritySchemes[s.Name]; !ok {
			return ErrTestSecurityThemeDoesNotExist
		}
	}

	// Request bodies must follow the schema provided in the spec for the appropriate route.
	op, err := t.getPath(spec)
	if err != nil {
		return err
	}
	if t.RequestBody != nil {
		if err := t.RequestBody.Validate(op); err != nil {
			return err
		}
	}
	if t.Response != nil {
		if err := t.Response.Validate(op); err != nil {
			return err
		}
	}
	return nil
}

func (t *Test) getPath(spec *openapi3.T) (*openapi3.Operation, error) {
	isNotNil := func(o *openapi3.Operation) (*openapi3.Operation, error) {
		if o == nil {
			return nil, ErrTestPathDoesNotExist
		}
		return o, nil
	}

	pathItem := spec.Paths.Find(t.Route)
	if pathItem == nil {
		return nil, ErrTestPathDoesNotExist
	}
	switch t.Method {
	case http.MethodGet:
		return isNotNil(pathItem.Get)
	case http.MethodPost:
		return isNotNil(pathItem.Post)
	case http.MethodDelete:
		return isNotNil(pathItem.Delete)
	case http.MethodConnect:
		return isNotNil(pathItem.Connect)
	case http.MethodHead:
		return isNotNil(pathItem.Head)
	case http.MethodOptions:
		return isNotNil(pathItem.Options)
	case http.MethodPatch:
		return isNotNil(pathItem.Patch)
	case http.MethodPut:
		return isNotNil(pathItem.Put)
	case http.MethodTrace:
		return isNotNil(pathItem.Trace)
	}

	return nil, ErrTestPathDoesNotExist
}
